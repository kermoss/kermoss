= Getting Started
== Prerequisites

Kermoss Framework runs on Java 8 and above, and also uses the following direct dependencies:

* spring-boot version 2.2.4 and above
* spring data jpa
* spring kafka
* spring cloud openfeign

Regarding databases, kermoss is tested with oracle, postgresql and mysql

== Getting Kermoss

To be able to use kermoss in your project, add the following dependency in your pom.xml
====
[source,xml]
----
<dependency>
    <groupId>io.kermoss</groupId>
    <artifactId>reactive-business-flow</artifactId>
    <version>${io.kermoss.version}</version>
</dependency>
----
====

=== connect kermoss to your database   

Kermoss uses ** Liquibase ** (an open source database change management tool) to manage the versioning of its database schema, if you already have liquibase in your project, you just have to add only this line to your db.changelog-master.xml file

[source,xml]
----
<include file="db/changelog/db-kermoss-master.xml" relativeToChangelogFile="false"/>
---- 
If your project does not include the ** liquibase ** tool, in this case add the following configuration in your pom.xml in the section menu:build[plugins]

====
[source,xml]
----
<plugin>
  <groupId>org.liquibase</groupId>
   <artifactId>liquibase-maven-plugin</artifactId>
   <configuration>
	<propertyFile>src/main/resources/liquibase.properties</propertyFile> <1>
	</configuration>
</plugin>
----
<1> create the liquibase.properties file in the menu:src[main>resources] location with the following elements:

[source, properties]
----
url=jdbc:postgresql://localhost:5432/pizzashop <1>
username=postgres <2>
password=mysecretpassword <3>
driver=org.postgresql.Driver <4>
changeLogFile=db/changelog/db.changelog-master.xml <5>
----
for (1)-(2)-(3)-(4) change them with those of your own database .

for (5) create db.changelog-master.xml file in the menu:src[main>resources>db>changelog] folder in your project with the following content:

[source, xml]
----
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<databaseChangeLog xmlns="http://www.liquibase.org/xml/ns/dbchangelog" xmlns:ext="http://www.liquibase.org/xml/ns/dbchangelog-ext" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog-ext http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-ext.xsd http://www.liquibase.org/xml/ns/dbchangelog http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-3.4.xsd">
    <include file="db/changelog/db-kermoss-master.xml" relativeToChangelogFile="false"/>
</databaseChangeLog>
----
it's almost finished, run the maven command to import the kermoss schema into your database:

[source, shell]
----
mvn process-resources liquibase:update
----     
====

Normally Kermoss should integrate into your project with your existing dataSource and transactionManager configuration with no worries.

If you have not yet configured your dataSource , put this configuration in your application.yml file, the database we took as an example is postgresql (oracle or mysql are also supported)

====
[source,yaml]
----
spring.datasource:
  url: jdbc:postgresql://localhost:5432/pizzashop
  username: postgres
  password: mysecretpassword
  driver-class-name: org.postgresql.Driver
  hikari: <1>
    maximum-pool-size: 10


# Hibernate settings
spring.jpa.show-sql: true <2>
spring.jpa.properties.hibernate.dialect: org.hibernate.dialect.PostgreSQLDialect
spring.jpa.properties.hibernate.hbm2ddl.auto: validate <3>
----
<1> kermoss uses hikari pool by default, there is no restriction to choose for example tomcat or c3p0 as connection pool
<2> For debugging sql queries .
<3> We recommend setting this value to ** validate ** for the production environment    
====

== First steps to master Kermoss

To concretely master the different concepts of kermoss we will refer to the pizzashop example, for more details on the source code of the pizzashop project see https://github.com/kermoss/kermoss/tree/master/saga-worker[here]

The pizzashop project consists of three microservices:

* pizzashop: contains the logic for ordering pizza, cooking, and payment
* pizzaship: contains the delivery logic
* market: provides the necessary ingredients for a pizza

== How to run pizza shop microservices

====
[source, shell]

git clone https://github.com/kermoss/kermoss.git
cd kermoss
mvn clean install <1>
cd saga-worker/target
java -jar saga-worker-${version}.jar --spring.profiles.active=dev,shop <2>
java -jar saga-worker-${version}.jar --spring.profiles.active=dev,ship <3>
java -jar saga-worker-${version}.jar --spring.profiles.active=dev,market <4>

<1> This will build the whole project and include saga-worker which the maven module containing the source code for the pizza shop microservices 
<2> launch the pizzshop microservice in dev mode
<3> launch the pizzaship microservice in dev mode
<4> launche the microservice market in dev mode

_Each microservice has its own configuration file you can find and modify it in the saga-worker / resources folder example application-market.yml is the configuration file for market microservice_  
====

If all goes well without error, this entry point **http://localhost:8081/pizza/test/order** allows you to run the pizza order scenario.

== How to run pizza shop as single monolith application
====
[source,shell]
----
java -jar saga-worker-${version}.jar --spring.profiles.active=dev,single <1>
----
<1> launch the pizzshop application in dev mode

_application-single.yml est le fichier de configuration yaml pour pizza shop application_   
====

== BFM & pizzashop together üôè

[NOTE]
====
Kermoss by default uses communication in asynchronous mode even if the pizzaship service is not available it can continue while waiting for it to be up and running, but this does not prevent kermoss from also supporting synchronous communication in blocking mode, this will be illustrated in the scenario when pizzashop microservice requests the service market in blocking mode, if there is not enough ingredient or the service does not respond, the pizzashope service stops the global transaction    
====

The pizza shop microservice is the owner and initiator of the global transaction, so by default kermoss assigns it the role of the orchestrator of the entire distributed transaction cycle, all communication in the BFM (Business Flow Model) internally in pizza shop are driven by events, on the other hand communication with other microservices (market and pizza ship) are driven by commands


[TIP]
====
A BFM (Business Flow Model) is just a set of components in the form of a java class called ** workers ** (global and local transaction)

.A BFM is made up of :

* ** worker ** class that extends GlobalTransactionWorker allowing to start or close a global transaction by listening on events..
* ** worker ** class that extends LocalTransactionWorker allowing to start or close or rollback (compensate) a local transaction by listening on events.
* Each ** worker ** communicate internally by events and can send commands to remote BFMs all this happens through ** TransactionStepDefinition ** these are in a way the equivalent of RouteBuilder in the camel project.    
====

== Kermoss : project organization

it is better to have the following organization for your project, however you are free to choose a suitable structure for your project, the objective of this part is to show you the different components that you would need to develop your project with kermoss.   

----
üìí pizza-shop <1>
  üìÑ pom.xml
  üìÇ src/main/java
    üìÇ org.pizzasho <2>
      üìÇ api <3>
      üìÇ cmd <4>
      üìÇ decoder <5>
      üìÇ domain <6>
      üìÇ event <7>
      üìÇ exception <8>
      üìÇ service <9>
      üìÇ worker <10>
        üìÑ OrderPizzaStateWorker.java <11>
  üìÇ src/main/resources
    üìÑ application.yml <12>  
----
<1> your project root
<2> your root package: the domain name
<3> you can create your rest api here
<4> package containing the commands to send to remote BFMs
<5> package contains decoder services; when a command lands in a remote microservice, the decoder service creates an event based on the commands subject (a subject is only a key that allows the mapping with the distination of the command), for this purpose a given worker (global or local transaction) receives this command by listening on this event.   
<6> your domain business logic (model + repositories + services)
<7> package containing the events for internal communication between the different workers (Global and Local transaction)
<8> package containing exceptions
<9> package containing the services of the application layer
<10> package containing the BFM as a component, we recommend that worker adhere to the following convention: <serviceName> Worker.java
<11> contains the configuration of kermoss as well as your application

== Create your first globalTransaction worker

You just have to create a class OrderPizzaStateWorker.java (see the example of pizzashop) which extends GlobalTransactionWorker and annotate it with spring @Component annotation

====
[source, java, linenums]
----
@Component
public class OrderPizzaStateWorker extends GlobalTransactionWorker<OrderPizzaReceivedEvent, OrderPizzaReadyEvent> {
    
    public OrderPizzaStateWorker() {
        super(new WorkerMeta("OrderPizzaService")); <1>
    }

    @Override
    @BusinessGlobalTransactional <2>
    public GlobalTransactionStepDefinition onStart(OrderPizzaReceivedEvent orderPizzaReceivedEvent)  { <3>
        return GlobalTransactionStepDefinition.builder() <4>
                .in(orderPizzaReceivedEvent)<5>
                .meta(this.meta)<6>
                .process(Optional.empty())<7>
                .blow(Stream.of(new OrderPizzaReadyEvent(orderPizzaReceivedEvent.getCartId())))<8>
                .build();
    }

    @Override
    @CommitBusinessGlobalTransactional <9>
    public GlobalTransactionStepDefinition onComplete(OrderPizzaReadyEvent orderPizzaReadyEvent ) { <10>
        return GlobalTransactionStepDefinition.builder()
                .in(orderPizzaReadyEvent)
                .meta(this.meta)
                .process(Optional.empty())
                .build();
    }
}
----
<1> Worker Meta data, contains the unique name of the global Transaction, it allows to identify it, and to attach the different local transaction workers that must be subordinated by this transaction
<2> Transaction Demarcation: start a new global transaction by listening to an event
<3> listen on an event of type OrderPizzaReceivedEvent
<4> Create a Global Transaction StepDefinition it is the equivalent of a route builder it allows to execute a command chain
<5> allow the Global Transaction StepDefinition to consume the event
<6> pass the meta data reference to the Global Transaction StepDefinition
<7> you can put a side effect here
<8> trigger an event stream
<9> Transaction Demarcation: Commit and close Global Transaction by listening to an event
<10> listen on an event of type orderPizzaReadyEvent
====

== Begin a new Global transaction

To be able to start a new global transaction, start an event with:

====
[source, java ,linenums]
----
@Autowired <1>
ApplicationEventPublisher applicationEventPublisher;

@Transactional <2>
    public void prepareOrder(Cart cart){
        orders.put(cart.getId(), cart);
        applicationEventPublisher.publishEvent(new OrderPizzaReceivedEvent(cart.getId()));<3>
    }
----
<1> inject a spring ApplicationEventPublisher to publish en event
<2> decorate your method with the classic ** @ Transactional ** annotation from spring
<3> publish your event to start the global transaction   
====

== Link a global transaction context

Supposing that in some situation you want to launch an event from your business logic to call a worker (ex: play, commit, or rollback a localTransaction), in this case you need a way to attach the context of a global transaction, by persisting its id in your business model at this level you can communicate with your BFM, outside the context of the global transaction

Kermoss provides this feature by offering the attach method in the pipeline ** GlobalTransactionStepDefinition ** or ** LocalTransactionStepDefinition ** in this case you can bind a global transaction context either from GlobalTransaction worker, or LocalTransaction Worker.

[source,java]
----
       return GlobalTransactionStepDefinition.builder()
                ...
                .attach(gtx ->orderSevice.saveGlobalTransactionId(gtx)) <1>
                .build();
    }
----
 
== Call your BFM workers from outside  

You can call your BFM at all levels from your business logic by injecting the BusinessFlow component of the kermoss framework into your services then call the ** access ** method
      
[source,java]
----
@Service
public class BakingService {

    @Autowired
    BusinessFlow businessFlow; <1>
    	
    private static final Logger log = LoggerFactory.getLogger(BakingService.class);
    @Transactional <2>
    public void bake(String gtx, String cartid){
        businessFlow.access(gtx, new BakingPizzaReadyEvent(cartid));	<3>
    }
}
----
<1> inject a kermoss ** BusinessFlow ** service
<2> wrap your business logic with the classic spring annoation ** @ Transactional **, to ensure that your business logic is transactional including BFM 
<3> call the access method by injecting it with a global transaction id already persisted in your business model, then the second parameter used as event to commit the local transaction ** BakerPizzaServiceWorker ** in the pizzashop microservice

== Send a command To a remote BFM

//Envoyer une command √† un BFM distant est une mission facile pour kermoss fra   

=== Configure your layer transport
== Enlist a Local Transaction Worker